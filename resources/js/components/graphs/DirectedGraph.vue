<template>
    <div ref="graphContainer" />
</template>

<script setup>
// This script is generated by ChatGPT
import { ref, onMounted, watch } from "vue";
import * as d3 from "d3";

// Props for nodes and links
const props = defineProps({
    nodes: {
        type: Array,
        required: true,
    },
    links: {
        type: Array,
        required: true,
    },
});

const graphContainer = ref(null); // Reference to the container div

// Function to create the directed graph
function createGraph(nodes, links) {
    // Clear existing graph (if any)
    d3.select(graphContainer.value).selectAll("*").remove();

    const width = window.innerWidth;
    const height = window.innerHeight;

    // Create the SVG container
    const svg = d3
        .select(graphContainer.value)
        .append("svg")
        .attr("width", "100vw")
        .attr("height", "100vh");

    // Add a group for links and nodes
    const g = svg.append("g");

    // Add zoom behavior
    const zoom = d3.zoom().scaleExtent([0.2, 3]).on("zoom", function (event) {
        g.attr("transform", event.transform);
    });

    svg.call(zoom);

    // Set the initial zoom level to 0.2
    svg.call(zoom.transform, d3.zoomIdentity.scale(0.2));

    // Define marker for arrowheads
    svg.append("defs")
        .append("marker")
        .attr("id", "arrowhead")
        .attr("viewBox", "-0 -5 10 10")
        .attr("refX", 23)
        .attr("refY", 0)
        .attr("orient", "auto")
        .attr("markerWidth", 6)
        .attr("markerHeight", 6)
        .append("path")
        .attr("d", "M 0,-5 L 10 ,0 L 0,5")
        .attr("fill", "#EFEFEF");

    // Create force simulation
    const simulation = d3
        .forceSimulation(nodes)
        .force("link", d3.forceLink(links).id((d) => d.id).distance(100))
        .force("charge", d3.forceManyBody().strength(-200))
        .force("center", d3.forceCenter(width / 2 / 0.2, height / 2 / 0.2));

    // Add links
    const link = g
        .append("g")
        .selectAll("line")
        .data(links)
        .enter()
        .append("line")
        .attr("stroke-width", 5)
        .attr("stroke", "#EFEFEF")
        .attr("fill", "#EFEFEF")
        .attr("marker-end", "url(#arrowhead)");

    // Add nodes with tooltip
    const node = g
        .append("g")
        .selectAll("g")  // Create a group for each node to hold both circle and text
        .data(nodes)
        .enter()
        .append("g")  // Group for each node (circle + text)
        .call(
            d3
                .drag()
                .on("start", function (event, d) {
                    if (!event.active) simulation.alphaTarget(0.3).restart();
                    d.fx = d.x;
                    d.fy = d.y;
                })
                .on("drag", function (event, d) {
                    d.fx = event.x;
                    d.fy = event.y;
                })
                .on("end", function (event, d) {
                    if (!event.active) simulation.alphaTarget(0);
                    d.fx = null;
                    d.fy = null;
                })
        );

    // Add the circle for each node
    node.append("circle")
        .attr("r", (d) => {
            if (d.id === "100" || d.id === "200" || d.id === "300" || d.id === "310" || d.id === "320" || d.id === "400" || d.id === "500" || d.id === "700" || d.id === "750") {
                return 30;  // Larger size for id 100
            } else {
                return 20;  // Default circle size
            }
        })
        .attr("fill", (d) => {
            if (d.id.startsWith('100') || d.id.startsWith('760')) {
                return '#eb422f';
            } else if (d.id.startsWith('1')) {
                return '#cd30f0';
            } else if (d.id.startsWith('2')) {
                return '#34aeeb';
            } else if (d.id.startsWith('3')) {
                return '#2bf060';
            } else if (d.id.startsWith('4')) {
                return '#f5e342';
            } else if (d.id.startsWith('5')) {
                return '#f07c29';
            } else if (d.id.startsWith('6')) {
                return '#f07c29';
            } else if (d.id.startsWith('7')) {
                return '#f516c8';
            } else {
                return '#fff';
            }
        })
        // Add mouseover and mouseout event listeners for tooltip
        .on("mouseover", function (event, d) {
            handleMouseOver(event, d);  // Show tooltip
        })
        .on("mouseout", handleMouseOut);  // Hide tooltip

    // Add text inside each node (centered)
    node.append("text")
        .attr("x", 0)
        .attr("y", 0)
        .attr("text-anchor", "middle")
        .attr("fill", "black")
        .attr("font-size", "16px")
        .attr("dy", ".35em")
        .text((d) => d.id)
        .style("pointer-events", "none");

    // Tooltip div
    const tooltip = d3
        .select(graphContainer.value)
        .append("div")
        .style("position", "absolute")
        .style("visibility", "hidden")
        .style("background", "rgba(0, 0, 0, 0.7)")
        .style("color", "white")
        .style("padding", "10px")
        .style("border-radius", "10px")
        .style("pointer-events", "none")
        .style("max-width", "400px");

    // Handle mouse over event to show tooltip
    function handleMouseOver(event, d) {
        const choicesHtml = d.choices ?
            "<br>" +
            d.choices.map((item, i) => `<strong>Answer ${i + 1}:</strong> ${item.text} <strong>&#8594;</strong> ${item.destination_id}`)
                .join("<br>") : '';

        tooltip.style("visibility", "visible")
            .html(`
            <strong>ID:</strong> ${d.id} <br>
            <strong>${d.character}:</strong>
            "${d.content}" <br>
            ${choicesHtml}
        `);
    }

    // Handle mouse out event to hide tooltip
    function handleMouseOut() {
        tooltip.style("visibility", "hidden");
    }

    // Update positions on each simulation tick
    simulation.on("tick", () => {
        // Update link positions
        link
            .attr("x1", (d) => d.source.x)
            .attr("y1", (d) => d.source.y)
            .attr("x2", (d) => d.target.x)
            .attr("y2", (d) => d.target.y);

        // Update circle positions (not the g group)
        node.selectAll("circle")
            .attr("cx", (d) => d.x)
            .attr("cy", (d) => d.y);

        // Update text positions
        node.selectAll("text")
            .attr("x", (d) => d.x)
            .attr("y", (d) => d.y);
    });

    // Update tooltip position with mouse movement
    svg.on("mousemove", function (event) {
        tooltip
            .style("top", `${event.clientY + 10}px`)
            .style("left", `${event.clientX + 10}px`);
    });
}

// Run the graph creation when the component is mounted
onMounted(() => {
    createGraph(props.nodes, props.links);
});

// Watch for changes in nodes and links and recreate the graph
watch(
    [() => props.nodes, () => props.links],
    ([newNodes, newLinks]) => {
        createGraph(newNodes, newLinks);
    }
);
</script>
